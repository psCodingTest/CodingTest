# 개똥벌레

- https://www.acmicpc.net/problem/21315

<br>

## 시간복잡도

## 코드

```java
import java.io.*;
import java.util.*;

public class Main {

    static int N;
    static int[] target;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        target = new int[N];
        for (int i = 0; i < N; i++) target[i] = Integer.parseInt(st.nextToken());

        // 2^k <= N 인 최대 k 올바르게 계산
        int maxK = 0;
        while (Math.pow(2, maxK + 1) <= N) maxK++;

        // 시작 덱 1..N
        int[] baseArr = new int[N];
        for (int i = 0; i < N; i++) baseArr[i] = i + 1;

        for (int k1 = 1; k1 <= maxK; k1++) {
            int[] afterK1 = shuffle(baseArr, k1);

            for (int k2 = 1; k2 <= maxK; k2++) {
                int[] afterK2 = shuffle(afterK1, k2);

                if (Arrays.equals(target, afterK2)) {
                    System.out.println(k1 + " " + k2);
                    return;
                }
            }
        }
    }

    static int[] shuffle(int[] arr, int k) {
        int[] res = arr.clone();
        int block = 1 << k; // 2^k

        // 1단계: 덱의 바닥에서 block장을 통째로 앞으로
        {
            int[] tmp = new int[N];
            System.arraycopy(res, N - block, tmp, 0, block);
            System.arraycopy(res, 0, tmp, block, N - block);
            res = tmp;
        }

        // 이후 단계: '현재 위쪽 블록'의 바닥에서 block/2, block/4, ..., 1장을 앞으로
        while (block > 1) {
            int next = block >> 1; // block/2
            int[] tmp = new int[N];
            int idx = 0;

            // 위쪽 블록의 '하단 next장'을 앞으로
            System.arraycopy(res, block - next, tmp, idx, next); idx += next;
            // 위쪽 블록의 나머지(상단 부분)
            System.arraycopy(res, 0, tmp, idx, block - next);   idx += (block - next);
            // 나머지 카드들(블록 아래쪽)은 그대로 뒤에
            System.arraycopy(res, block, tmp, idx, N - block);

            res = tmp;
            block = next; // 이제 이 next장이 '직전에 올린 블록'이 됨 (항상 맨 위에 위치)
        }
        return res;
    }

}
```